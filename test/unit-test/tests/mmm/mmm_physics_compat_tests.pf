@test
subroutine test_mmm_physics_compat_init()
    use funit
    use mmm_physics_compat, only: mmm_physics_compat_init

    integer :: isfflx, isftcflx, iz0tlnd
    character(100) :: errmsg
    integer :: errflg

    isfflx = huge(0)
    isftcflx = huge(0)
    iz0tlnd = huge(0)

    call mmm_physics_compat_init( &
        isfflx, isftcflx, iz0tlnd, &
        errmsg, errflg)

    ! Should set options that are specific to MMM physics.
    @assertEqual(1, isfflx)
    @assertEqual(0, isftcflx)
    @assertEqual(0, iz0tlnd)
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_compat_init

@test
subroutine test_mmm_physics_compat_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: mmm_physics_compat_run

    integer, parameter :: ncol = 100, pver = 10
    integer :: nstep
    real(kind_phys) :: dt
    real(kind_phys) :: theta_curr(ncol, pver), theta_prev(ncol, pver), qv_curr(ncol, pver), qv_prev(ncol, pver)
    real(kind_phys) :: icefrac(ncol), landfrac(ncol)
    character(256) :: scheme_name
    real(kind_phys) :: rthdynten(ncol, pver), rqvdynten(ncol, pver)
    real(kind_phys) :: xland(ncol)
    character(100) :: errmsg
    integer :: errflg

    integer :: i

    nstep = 0
    dt = 20.0_kind_phys

    theta_curr(:, :) = 293.15_kind_phys
    theta_prev(:, :) = 273.15_kind_phys
    qv_curr(:, :) = 0.03_kind_phys
    qv_prev(:, :) = 0.01_kind_phys
    icefrac(1:50) = 0.0_kind_phys
    icefrac(51:100) = [(0.01_kind_phys + real(i - 1, kind_phys) * 0.02_kind_phys, i = 1, 50)]
    landfrac(1:50) = [(0.01_kind_phys + real(i - 1, kind_phys) * 0.02_kind_phys, i = 1, 50)]
    landfrac(51:100) = 0.0_kind_phys
    scheme_name = ''
    rthdynten(:, :) = huge(0.0_kind_phys)
    rqvdynten(:, :) = huge(0.0_kind_phys)
    xland(:) = huge(0.0_kind_phys)

    call mmm_physics_compat_run( &
        nstep, &
        dt, &
        theta_curr, theta_prev, qv_curr, qv_prev, &
        icefrac, landfrac, &
        scheme_name, &
        rthdynten, rqvdynten, &
        xland, &
        errmsg, errflg)

    ! Should set scheme name.
    @assertEqual('mmm_physics_compat_run', scheme_name)
    ! Tendencies should be zero at start (nstep = 0).
    @assertEqual(0.0_kind_phys, rthdynten)
    @assertEqual(0.0_kind_phys, rqvdynten)
    ! Should set land mask according to ice and land fractions.
    @assertEqual(2.0_kind_phys, xland(1:25))
    @assertEqual(1.0_kind_phys, xland(26:50))
    @assertEqual(2.0_kind_phys, xland(51))
    @assertEqual(1.0_kind_phys, xland(52:100))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)

    nstep = 1

    scheme_name = ''
    rthdynten(:, :) = huge(0.0_kind_phys)
    rqvdynten(:, :) = huge(0.0_kind_phys)
    xland(:) = huge(0.0_kind_phys)

    call mmm_physics_compat_run( &
        nstep, &
        dt, &
        theta_curr, theta_prev, qv_curr, qv_prev, &
        icefrac, landfrac, &
        scheme_name, &
        rthdynten, rqvdynten, &
        xland, &
        errmsg, errflg)

    ! Should set scheme name.
    @assertEqual('mmm_physics_compat_run', scheme_name)
    ! Should compute tendencies correctly afterwards (nstep > 0).
    @assertEqual(1.0_kind_phys, rthdynten, epsilon(0.0_kind_phys))
    @assertEqual(0.001_kind_phys, rqvdynten, epsilon(0.0_kind_phys))
    ! Should set land mask according to ice and land fractions.
    @assertEqual(2.0_kind_phys, xland(1:25))
    @assertEqual(1.0_kind_phys, xland(26:50))
    @assertEqual(2.0_kind_phys, xland(51))
    @assertEqual(1.0_kind_phys, xland(52:100))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_compat_run

@test
subroutine test_mmm_physics_accumulate_tendencies_timestep_init()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: mmm_physics_accumulate_tendencies_timestep_init

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: dudt(ncol, pver), dvdt(ncol, pver), dtdt(ncol, pver)
    real(kind_phys) :: rublten(ncol, pver), rucuten(ncol, pver), rvblten(ncol, pver), rvcuten(ncol, pver)
    real(kind_phys) :: rthblten(ncol, pver), rthcuten(ncol, pver), rthratenlw(ncol, pver), rthratensw(ncol, pver)
    real(kind_phys) :: rqvblten(ncol, pver), rqvcuten(ncol, pver)
    real(kind_phys) :: rqccuten(ncol, pver)
    real(kind_phys) :: rqicuten(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    dudt(:, :) = huge(0.0_kind_phys)
    dvdt(:, :) = huge(0.0_kind_phys)
    dtdt(:, :) = huge(0.0_kind_phys)

    rublten(:, :) = huge(0.0_kind_phys)
    rucuten(:, :) = huge(0.0_kind_phys)
    rvblten(:, :) = huge(0.0_kind_phys)
    rvcuten(:, :) = huge(0.0_kind_phys)

    rthblten(:, :) = huge(0.0_kind_phys)
    rthcuten(:, :) = huge(0.0_kind_phys)
    rthratenlw(:, :) = huge(0.0_kind_phys)
    rthratensw(:, :) = huge(0.0_kind_phys)

    rqvblten(:, :) = huge(0.0_kind_phys)
    rqvcuten(:, :) = huge(0.0_kind_phys)

    rqccuten(:, :) = huge(0.0_kind_phys)

    rqicuten(:, :) = huge(0.0_kind_phys)

    call mmm_physics_accumulate_tendencies_timestep_init( &
        dudt, dvdt, dtdt, &
        rublten, rucuten, rvblten, rvcuten, &
        rthblten, rthcuten, rthratenlw, rthratensw, &
        rqvblten, rqvcuten, &
        rqccuten, &
        rqicuten, &
        errmsg, errflg)

    ! Everything should be zeroed out.
    @assertEqual(0.0_kind_phys, dudt)
    @assertEqual(0.0_kind_phys, dvdt)
    @assertEqual(0.0_kind_phys, dtdt)

    @assertEqual(0.0_kind_phys, rublten)
    @assertEqual(0.0_kind_phys, rucuten)
    @assertEqual(0.0_kind_phys, rvblten)
    @assertEqual(0.0_kind_phys, rvcuten)

    @assertEqual(0.0_kind_phys, rthblten)
    @assertEqual(0.0_kind_phys, rthcuten)
    @assertEqual(0.0_kind_phys, rthratenlw)
    @assertEqual(0.0_kind_phys, rthratensw)

    @assertEqual(0.0_kind_phys, rqvblten)
    @assertEqual(0.0_kind_phys, rqvcuten)

    @assertEqual(0.0_kind_phys, rqccuten)

    @assertEqual(0.0_kind_phys, rqicuten)

    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_accumulate_tendencies_timestep_init

@test
subroutine test_mmm_physics_accumulate_tendencies_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: mmm_physics_accumulate_tendencies_run

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: dt, exner(ncol, pver)
    real(kind_phys) :: dudt(ncol, pver), dvdt(ncol, pver), dtdt(ncol, pver)
    real(kind_phys) :: theta(ncol, pver), qv(ncol, pver), qc(ncol, pver), qi(ncol, pver)
    real(kind_phys) :: rublten(ncol, pver), rucuten(ncol, pver), rvblten(ncol, pver), rvcuten(ncol, pver)
    real(kind_phys) :: rthblten(ncol, pver), rthcuten(ncol, pver), rthratenlw(ncol, pver), rthratensw(ncol, pver)
    real(kind_phys) :: rqvblten(ncol, pver), rqvcuten(ncol, pver)
    real(kind_phys) :: rqccuten(ncol, pver)
    real(kind_phys) :: rqicuten(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    dt = 20.0_kind_phys
    exner(:, :) = 1.0_kind_phys

    dudt(:, :) = 0.0_kind_phys
    dvdt(:, :) = 0.0_kind_phys
    dtdt(:, :) = 0.0_kind_phys

    theta(:, :) = 273.15_kind_phys
    qv(:, :) = 0.01_kind_phys
    qc(:, :) = 0.01_kind_phys
    qi(:, :) = 0.01_kind_phys

    rublten(:, :) = 0.1_kind_phys
    rucuten(:, :) = 0.1_kind_phys
    rvblten(:, :) = 0.1_kind_phys
    rvcuten(:, :) = 0.1_kind_phys

    rthblten(:, :) = 0.1_kind_phys
    rthcuten(:, :) = 0.1_kind_phys
    rthratenlw(:, :) = 0.1_kind_phys
    rthratensw(:, :) = 0.1_kind_phys

    rqvblten(:, :) = 0.00025_kind_phys
    rqvcuten(:, :) = 0.00025_kind_phys

    rqccuten(:, :) = 0.00025_kind_phys

    rqicuten(:, :) = 0.00025_kind_phys

    call mmm_physics_accumulate_tendencies_run( &
        dt, exner, &
        dudt, dvdt, dtdt, &
        theta, qv, qc, qi, &
        rublten, rucuten, rvblten, rvcuten, &
        rthblten, rthcuten, rthratenlw, rthratensw, &
        rqvblten, rqvcuten, &
        rqccuten, &
        rqicuten, &
        errmsg, errflg)

    ! Should accumulate MMM tendencies into CAM-SIMA ones.
    @assertEqual(0.2_kind_phys, dudt, epsilon(0.0_kind_phys))
    @assertEqual(0.2_kind_phys, dvdt, epsilon(0.0_kind_phys))
    @assertEqual(0.4_kind_phys, dtdt, epsilon(0.0_kind_phys))

    @assertEqual(281.15_kind_phys, theta, epsilon(0.0_kind_phys))
    @assertEqual(0.02_kind_phys, qv, epsilon(0.0_kind_phys))
    @assertEqual(0.015_kind_phys, qc, epsilon(0.0_kind_phys))
    @assertEqual(0.015_kind_phys, qi, epsilon(0.0_kind_phys))

    ! After the accumulation, tendencies should be zeroed out.
    @assertEqual(0.0_kind_phys, rublten)
    @assertEqual(0.0_kind_phys, rucuten)
    @assertEqual(0.0_kind_phys, rvblten)
    @assertEqual(0.0_kind_phys, rvcuten)

    @assertEqual(0.0_kind_phys, rthblten)
    @assertEqual(0.0_kind_phys, rthcuten)
    @assertEqual(0.0_kind_phys, rthratenlw)
    @assertEqual(0.0_kind_phys, rthratensw)

    @assertEqual(0.0_kind_phys, rqvblten)
    @assertEqual(0.0_kind_phys, rqvcuten)

    @assertEqual(0.0_kind_phys, rqccuten)

    @assertEqual(0.0_kind_phys, rqicuten)

    @assertEqual('', errmsg)
    @assertEqual(0, errflg)

    rublten(:, :) = 0.1_kind_phys
    rucuten(:, :) = 0.1_kind_phys
    rvblten(:, :) = 0.1_kind_phys
    rvcuten(:, :) = 0.1_kind_phys

    rthblten(:, :) = 0.1_kind_phys
    rthcuten(:, :) = 0.1_kind_phys
    rthratenlw(:, :) = 0.1_kind_phys
    rthratensw(:, :) = 0.1_kind_phys

    rqvblten(:, :) = 0.00025_kind_phys
    rqvcuten(:, :) = 0.00025_kind_phys

    rqccuten(:, :) = 0.00025_kind_phys

    rqicuten(:, :) = 0.00025_kind_phys

    call mmm_physics_accumulate_tendencies_run( &
        dt, exner, &
        dudt, dvdt, dtdt, &
        theta, qv, qc, qi, &
        rublten, rucuten, rvblten, rvcuten, &
        rthblten, rthcuten, rthratenlw, rthratensw, &
        rqvblten, rqvcuten, &
        rqccuten, &
        rqicuten, &
        errmsg, errflg)

    ! Should accumulate MMM tendencies into CAM-SIMA ones.
    @assertEqual(0.4_kind_phys, dudt, epsilon(0.0_kind_phys))
    @assertEqual(0.4_kind_phys, dvdt, epsilon(0.0_kind_phys))
    @assertEqual(0.8_kind_phys, dtdt, epsilon(0.0_kind_phys))

    @assertEqual(289.15_kind_phys, theta, epsilon(0.0_kind_phys))
    @assertEqual(0.03_kind_phys, qv, epsilon(0.0_kind_phys))
    @assertEqual(0.02_kind_phys, qc, epsilon(0.0_kind_phys))
    @assertEqual(0.02_kind_phys, qi, epsilon(0.0_kind_phys))

    ! After the accumulation, tendencies should be zeroed out.
    @assertEqual(0.0_kind_phys, rublten)
    @assertEqual(0.0_kind_phys, rucuten)
    @assertEqual(0.0_kind_phys, rvblten)
    @assertEqual(0.0_kind_phys, rvcuten)

    @assertEqual(0.0_kind_phys, rthblten)
    @assertEqual(0.0_kind_phys, rthcuten)
    @assertEqual(0.0_kind_phys, rthratenlw)
    @assertEqual(0.0_kind_phys, rthratensw)

    @assertEqual(0.0_kind_phys, rqvblten)
    @assertEqual(0.0_kind_phys, rqvcuten)

    @assertEqual(0.0_kind_phys, rqccuten)

    @assertEqual(0.0_kind_phys, rqicuten)

    @assertEqual('', errmsg)
    @assertEqual(0, errflg)

    call mmm_physics_accumulate_tendencies_run( &
        dt, exner, &
        dudt, dvdt, dtdt, &
        theta, qv, qc, qi, &
        rublten, rucuten, rvblten, rvcuten, &
        rthblten, rthcuten, rthratenlw, rthratensw, &
        rqvblten, rqvcuten, &
        rqccuten, &
        rqicuten, &
        errmsg, errflg)

    call mmm_physics_accumulate_tendencies_run( &
        dt, exner, &
        dudt, dvdt, dtdt, &
        theta, qv, qc, qi, &
        rublten, rucuten, rvblten, rvcuten, &
        rthblten, rthcuten, rthratenlw, rthratensw, &
        rqvblten, rqvcuten, &
        rqccuten, &
        rqicuten, &
        errmsg, errflg)

    ! Consecutive calls should be idempotent.
    @assertEqual(0.4_kind_phys, dudt, epsilon(0.0_kind_phys))
    @assertEqual(0.4_kind_phys, dvdt, epsilon(0.0_kind_phys))
    @assertEqual(0.8_kind_phys, dtdt, epsilon(0.0_kind_phys))

    @assertEqual(289.15_kind_phys, theta, epsilon(0.0_kind_phys))
    @assertEqual(0.03_kind_phys, qv, epsilon(0.0_kind_phys))
    @assertEqual(0.02_kind_phys, qc, epsilon(0.0_kind_phys))
    @assertEqual(0.02_kind_phys, qi, epsilon(0.0_kind_phys))

    @assertEqual(0.0_kind_phys, rublten)
    @assertEqual(0.0_kind_phys, rucuten)
    @assertEqual(0.0_kind_phys, rvblten)
    @assertEqual(0.0_kind_phys, rvcuten)

    @assertEqual(0.0_kind_phys, rthblten)
    @assertEqual(0.0_kind_phys, rthcuten)
    @assertEqual(0.0_kind_phys, rthratenlw)
    @assertEqual(0.0_kind_phys, rthratensw)

    @assertEqual(0.0_kind_phys, rqvblten)
    @assertEqual(0.0_kind_phys, rqvcuten)

    @assertEqual(0.0_kind_phys, rqccuten)

    @assertEqual(0.0_kind_phys, rqicuten)

    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_accumulate_tendencies_run

@test
subroutine test_mmm_physics_persist_states_init()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: mmm_physics_persist_states_init

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: theta_prev(ncol, pver), qv_prev(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    theta_prev(:, :) = huge(0.0_kind_phys)
    qv_prev(:, :) = huge(0.0_kind_phys)

    call mmm_physics_persist_states_init( &
        theta_prev, qv_prev, &
        errmsg, errflg)

    ! Previous states should be initialized to zero.
    @assertEqual(0.0_kind_phys, theta_prev)
    @assertEqual(0.0_kind_phys, qv_prev)
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_persist_states_init

@test
subroutine test_mmm_physics_persist_states_timestep_final()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: mmm_physics_persist_states_timestep_final

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: theta_curr(ncol, pver), theta_prev(ncol, pver), qv_curr(ncol, pver), qv_prev(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    theta_curr(:, :) = 273.15_kind_phys
    theta_prev(:, :) = huge(0.0_kind_phys)
    qv_curr(:, :) = 0.01_kind_phys
    qv_prev(:, :) = huge(0.0_kind_phys)

    call mmm_physics_persist_states_timestep_final( &
        theta_curr, theta_prev, qv_curr, qv_prev, &
        errmsg, errflg)

    ! Current states should not be modified.
    @assertEqual(273.15_kind_phys, theta_curr)
    @assertEqual(0.01_kind_phys, qv_curr)

    ! Previous states should be remembered.
    @assertEqual(273.15_kind_phys, theta_prev)
    @assertEqual(0.01_kind_phys, qv_prev)

    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_mmm_physics_persist_states_timestep_final

@test
subroutine test_compute_air_density_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: compute_air_density_run

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: pdel(ncol, pver), gravit, dz(ncol, pver)
    real(kind_phys) :: rho(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    pdel(:, :) = 98.0_kind_phys
    gravit = 9.8_kind_phys
    dz(:, :) = 10.0_kind_phys
    rho(:, :) = huge(0.0_kind_phys)

    call compute_air_density_run( &
        pdel, gravit, dz, &
        rho, &
        errmsg, errflg)

    ! Should compute air density correctly.
    @assertEqual(1.0_kind_phys, rho, epsilon(0.0_kind_phys))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_compute_air_density_run

@test
subroutine test_compute_atmosphere_layer_thickness_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: compute_atmosphere_layer_thickness_run

    integer, parameter :: ncol = 100, pver = 10, pverp = 11
    real(kind_phys) :: zisfc(ncol, pverp)
    real(kind_phys) :: dz(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    integer :: i

    do i = 1, pverp
        zisfc(:, i) = 10000.0_kind_phys - real(i - 1, kind_phys) * 1000.0_kind_phys
    end do

    dz(:, :) = huge(0.0_kind_phys)

    call compute_atmosphere_layer_thickness_run( &
        ncol, &
        zisfc, &
        dz, &
        errmsg, errflg)

    ! Should compute atmosphere layer thickness correctly.
    @assertEqual(1000.0_kind_phys, dz, epsilon(0.0_kind_phys))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_compute_atmosphere_layer_thickness_run

@test
subroutine test_compute_characteristic_grid_length_scale_init()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: compute_characteristic_grid_length_scale_init

    integer, parameter :: ncol = 100
    real(kind_phys) :: omega(ncol), rearth, dx(ncol)
    character(100) :: errmsg
    integer :: errflg

    omega(:) = 0.0001_kind_phys
    rearth = 6.371E6_kind_phys
    dx(:) = huge(0.0_kind_phys)

    call compute_characteristic_grid_length_scale_init( &
        omega, rearth, dx, &
        errmsg, errflg)

    ! Should compute characteristic grid length scale correctly.
    @assertEqual(6.371E4_kind_phys, dx, epsilon(0.0_kind_phys))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_compute_characteristic_grid_length_scale_init

@test
subroutine test_geopotential_height_wrt_sfc_at_if_to_msl_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: geopotential_height_wrt_sfc_at_if_to_msl_run

    integer, parameter :: ncol = 100, pverp = 11
    real(kind_phys) :: gravit, phis(ncol), zisfc(ncol, pverp)
    real(kind_phys) :: zimsl(ncol, pverp)
    character(100) :: errmsg
    integer :: errflg

    gravit = 9.8_kind_phys
    phis(:) = 98.0_kind_phys
    zisfc(:, :) = 10.0_kind_phys
    zimsl(:, :) = huge(0.0_kind_phys)

    call geopotential_height_wrt_sfc_at_if_to_msl_run( &
        ncol, &
        gravit, phis, zisfc, &
        zimsl, &
        errmsg, errflg)

    ! Should compute geopotential height wrt mean sea level at interface correctly.
    @assertEqual(20.0_kind_phys, zimsl, epsilon(0.0_kind_phys))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_geopotential_height_wrt_sfc_at_if_to_msl_run

@test
subroutine test_geopotential_height_wrt_sfc_to_msl_run()
    use ccpp_kinds, only: kind_phys
    use funit
    use mmm_physics_compat, only: geopotential_height_wrt_sfc_to_msl_run

    integer, parameter :: ncol = 100, pver = 10
    real(kind_phys) :: gravit, phis(ncol), zmsfc(ncol, pver)
    real(kind_phys) :: zmmsl(ncol, pver)
    character(100) :: errmsg
    integer :: errflg

    gravit = 9.8_kind_phys
    phis(:) = 98.0_kind_phys
    zmsfc(:, :) = 10.0_kind_phys
    zmmsl(:, :) = huge(0.0_kind_phys)

    call geopotential_height_wrt_sfc_to_msl_run( &
        ncol, &
        gravit, phis, zmsfc, &
        zmmsl, &
        errmsg, errflg)

    ! Should compute geopotential height wrt mean sea level correctly.
    @assertEqual(20.0_kind_phys, zmmsl, epsilon(0.0_kind_phys))
    @assertEqual('', errmsg)
    @assertEqual(0, errflg)
end subroutine test_geopotential_height_wrt_sfc_to_msl_run
