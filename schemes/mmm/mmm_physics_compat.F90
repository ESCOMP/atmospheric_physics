!> This module contains interstitial schemes that are specific to MMM physics.
module mmm_physics_compat
    implicit none

    private
    public :: mmm_physics_compat_run
    public :: mmm_physics_accumulate_tendencies_timestep_init
    public :: mmm_physics_accumulate_tendencies_run
    public :: mmm_physics_persist_states_init
    public :: mmm_physics_persist_states_timestep_final
    public :: compute_characteristic_grid_length_scale_init
    public :: geopotential_height_wrt_sfc_at_if_to_msl_run
    public :: geopotential_height_wrt_sfc_to_msl_run
contains
    !> \section arg_table_mmm_physics_compat_run Argument Table
    !! \htmlinclude mmm_physics_compat_run.html
    pure subroutine mmm_physics_compat_run( &
            nstep, &
            dt, &
            theta_curr, theta_prev, qv_curr, qv_prev, &
            rthdynten, rqvdynten, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        integer, intent(in) :: nstep
        real(kind_phys), intent(in) :: dt, &
                                       theta_curr(:, :), theta_prev(:, :), qv_curr(:, :), qv_prev(:, :)
        real(kind_phys), intent(out) :: rthdynten(:, :), rqvdynten(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        if (nstep == 0) then
            rthdynten(:, :) = 0.0_kind_phys
            rqvdynten(:, :) = 0.0_kind_phys
        else
            rthdynten(:, :) = (theta_curr(:, :) - theta_prev(:, :)) / dt
            rqvdynten(:, :) = (qv_curr(:, :) - qv_prev(:, :)) / dt
        end if
    end subroutine mmm_physics_compat_run

    !> \section arg_table_mmm_physics_accumulate_tendencies_timestep_init Argument Table
    !! \htmlinclude mmm_physics_accumulate_tendencies_timestep_init.html
    pure subroutine mmm_physics_accumulate_tendencies_timestep_init( &
            dudt, dvdt, dtdt, &
            rublten, rucuten, rvblten, rvcuten, &
            rthblten, rthcuten, rthratenlw, rthratensw, &
            rqvblten, rqvcuten, &
            rqccuten, &
            rqicuten, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        real(kind_phys), intent(out) :: dudt(:, :), dvdt(:, :), dtdt(:, :), &
                                        rublten(:, :), rucuten(:, :), rvblten(:, :), rvcuten(:, :), &
                                        rthblten(:, :), rthcuten(:, :), rthratenlw(:, :), rthratensw(:, :), &
                                        rqvblten(:, :), rqvcuten(:, :), &
                                        rqccuten(:, :), &
                                        rqicuten(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        ! Zero out tendencies at the beginning of each time step.

        ! Tendencies for feeding back to CAM-SIMA.
        dudt(:, :) = 0.0_kind_phys
        dvdt(:, :) = 0.0_kind_phys
        dtdt(:, :) = 0.0_kind_phys

        ! Tendencies generated by MMM physics.
        rublten(:, :) = 0.0_kind_phys
        rucuten(:, :) = 0.0_kind_phys
        rvblten(:, :) = 0.0_kind_phys
        rvcuten(:, :) = 0.0_kind_phys

        rthblten(:, :) = 0.0_kind_phys
        rthcuten(:, :) = 0.0_kind_phys
        rthratenlw(:, :) = 0.0_kind_phys
        rthratensw(:, :) = 0.0_kind_phys

        rqvblten(:, :) = 0.0_kind_phys
        rqvcuten(:, :) = 0.0_kind_phys

        rqccuten(:, :) = 0.0_kind_phys

        rqicuten(:, :) = 0.0_kind_phys
    end subroutine mmm_physics_accumulate_tendencies_timestep_init

    !> \section arg_table_mmm_physics_accumulate_tendencies_run Argument Table
    !! \htmlinclude mmm_physics_accumulate_tendencies_run.html
    pure subroutine mmm_physics_accumulate_tendencies_run( &
            dt, exner, &
            dudt, dvdt, dtdt, &
            theta, qv, qc, qi, &
            rublten, rucuten, rvblten, rvcuten, &
            rthblten, rthcuten, rthratenlw, rthratensw, &
            rqvblten, rqvcuten, &
            rqccuten, &
            rqicuten, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        real(kind_phys), intent(in) :: dt, exner(:, :)
        real(kind_phys), intent(inout) :: dudt(:, :), dvdt(:, :), dtdt(:, :), &
                                          theta(:, :), qv(:, :), qc(:, :), qi(:, :), &
                                          rublten(:, :), rucuten(:, :), rvblten(:, :), rvcuten(:, :), &
                                          rthblten(:, :), rthcuten(:, :), rthratenlw(:, :), rthratensw(:, :), &
                                          rqvblten(:, :), rqvcuten(:, :), &
                                          rqccuten(:, :), &
                                          rqicuten(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        ! Accumulate tendencies for feeding back to CAM-SIMA.
        dudt(:, :) = dudt(:, :) + (rublten(:, :) + rucuten(:, :))
        dvdt(:, :) = dvdt(:, :) + (rvblten(:, :) + rvcuten(:, :))
        dtdt(:, :) = dtdt(:, :) + (rthblten(:, :) + rthcuten(:, :) + rthratenlw(:, :) + rthratensw(:, :)) * exner(:, :)

        theta(:, :) = theta(:, :) + (rthblten(:, :) + rthcuten(:, :) + rthratenlw(:, :) + rthratensw(:, :)) * dt
        qv(:, :) = qv(:, :) + (rqvblten(:, :) + rqvcuten(:, :)) * dt
        qc(:, :) = qc(:, :) + rqccuten(:, :) * dt
        qi(:, :) = qi(:, :) + rqicuten(:, :) * dt

        ! After the accumulation, zero out tendencies generated by MMM physics so that this subroutine is idempotent.
        rublten(:, :) = 0.0_kind_phys
        rucuten(:, :) = 0.0_kind_phys
        rvblten(:, :) = 0.0_kind_phys
        rvcuten(:, :) = 0.0_kind_phys

        rthblten(:, :) = 0.0_kind_phys
        rthcuten(:, :) = 0.0_kind_phys
        rthratenlw(:, :) = 0.0_kind_phys
        rthratensw(:, :) = 0.0_kind_phys

        rqvblten(:, :) = 0.0_kind_phys
        rqvcuten(:, :) = 0.0_kind_phys

        rqccuten(:, :) = 0.0_kind_phys

        rqicuten(:, :) = 0.0_kind_phys
    end subroutine mmm_physics_accumulate_tendencies_run

    !> \section arg_table_mmm_physics_persist_states_init Argument Table
    !! \htmlinclude mmm_physics_persist_states_init.html
    pure subroutine mmm_physics_persist_states_init( &
            theta_prev, qv_prev, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        real(kind_phys), intent(out) :: theta_prev(:, :), qv_prev(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        ! For remembering the model states from the previous time step. They must be allocated at model initialization
        ! because they need to persist across time steps.
        theta_prev(:, :) = 0.0_kind_phys
        qv_prev(:, :) = 0.0_kind_phys
    end subroutine mmm_physics_persist_states_init

    !> \section arg_table_mmm_physics_persist_states_timestep_final Argument Table
    !! \htmlinclude mmm_physics_persist_states_timestep_final.html
    pure subroutine mmm_physics_persist_states_timestep_final( &
            theta_curr, theta_prev, qv_curr, qv_prev, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        real(kind_phys), intent(in) :: theta_curr(:, :), qv_curr(:, :)
        real(kind_phys), intent(out) :: theta_prev(:, :), qv_prev(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        ! Remember the model states at this time step. When the next time step comes, they will become
        ! the model states from the previous one.
        theta_prev(:, :) = theta_curr(:, :)
        qv_prev(:, :) = qv_curr(:, :)
    end subroutine mmm_physics_persist_states_timestep_final

    !> \section arg_table_compute_characteristic_grid_length_scale_init Argument Table
    !! \htmlinclude compute_characteristic_grid_length_scale_init.html
    pure subroutine compute_characteristic_grid_length_scale_init( &
            omega, rearth, dx, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        real(kind_phys), intent(in) :: omega(:), rearth
        real(kind_phys), intent(out) :: dx(:)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        errmsg = ''
        errflg = 0

        ! Grid sizes do not change with time. Set them just once at model initialization for better performance.

        ! Compute grid sizes in meters. This is trivial for models with regular grids like WRF,
        ! but not so straightforward for models with unstructured grids like CAM-SIMA. Here, the square root of cell area is used.
        dx(:) = sqrt(omega(:) * (rearth ** 2))
    end subroutine compute_characteristic_grid_length_scale_init

    !> \section arg_table_geopotential_height_wrt_sfc_at_if_to_msl_run Argument Table
    !! \htmlinclude geopotential_height_wrt_sfc_at_if_to_msl_run.html
    pure subroutine geopotential_height_wrt_sfc_at_if_to_msl_run( &
            ncol, &
            gravit, phis, zisfc, &
            zimsl, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        integer, intent(in) :: ncol
        real(kind_phys), intent(in) :: gravit, phis(:), zisfc(:, :)
        real(kind_phys), intent(out) :: zimsl(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        integer :: i

        errmsg = ''
        errflg = 0

        ! Convert geopotential height wrt surface at interface to geopotential height wrt mean sea level at interface,
        ! in accordance with its normal definition.
        do i = 1, ncol
            zimsl(i, :) = phis(i) / gravit + zisfc(i, :)
        end do
    end subroutine geopotential_height_wrt_sfc_at_if_to_msl_run

    !> \section arg_table_geopotential_height_wrt_sfc_to_msl_run Argument Table
    !! \htmlinclude geopotential_height_wrt_sfc_to_msl_run.html
    pure subroutine geopotential_height_wrt_sfc_to_msl_run( &
            ncol, &
            gravit, phis, zmsfc, &
            zmmsl, &
            errmsg, errflg)
        use ccpp_kinds, only: kind_phys

        integer, intent(in) :: ncol
        real(kind_phys), intent(in) :: gravit, phis(:), zmsfc(:, :)
        real(kind_phys), intent(out) :: zmmsl(:, :)
        character(*), intent(out) :: errmsg
        integer, intent(out) :: errflg

        integer :: i

        errmsg = ''
        errflg = 0

        ! Convert geopotential height wrt surface to geopotential height wrt mean sea level, in accordance with
        ! its normal definition.
        do i = 1, ncol
            zmmsl(i, :) = phis(i) / gravit + zmsfc(i, :)
        end do
    end subroutine geopotential_height_wrt_sfc_to_msl_run
end module mmm_physics_compat
